* TODO

- [ ] Class definitions
  - [ ] constructor
  - [ ] getters
  - [ ] recognizer
- [ ] Inheritance
  - [ ] Slot inheritance
  - [ ] Subtyping
  - [ ] Multiple inheritance

* Sketch

(def-class <classname> <slot1> <slot2> ... <slotn>)
  |
generates
  |
  |    - Constructor
  |--> (defun make-<classname> (&key <slot_1> <slot_2> ... <slot_n>) ...)
  |
  |    - Getters
  |--> (defun <classname>-<slot_1> (obj) ...)
  |--> (defun <classname>-<slot_2> (obj) ...)
  |                   ...
  |--> (defun <classname>-<slot_n> (obj) ...)
  |
  |    - Recognizer
  |--> (defun <classname>? (obj) ...)
   
** Class definitions

Object could be a lambda (a closure) that functions as a database and responds
to queries (getters and recognizer).

Slots could be accessed via a map (an hash-table, for instance) that associates
the slots to the values. The values could be initialized to #f by default. This
map would belong to the closure and could be accessed by calling the closure
with an appropriate parameter. The recognizer would work in a similar way: the
closure would have a variable (that could be called "classname", for instance)
whose value is the name of the class.

** Inheritance

Inheritance could be implemented by composition (kind of what you would do if
you wanted to do this in C): creating an instance of the superclass and then
wrapping it in an object of the subclass. In this case, we have a function that
describes the class, as described in the previous section, and that has an
instance of the superclass (which itself is a function) as a variable.

Slot accessing and recognizing work by delegating to the superclass. This also
solves subtyping.

Multiple inheritance works either by successively wrapping superclasses (easier)
or by mantaining a stack superclasses (more difficult).

** Example

#+BEGIN_SRC emacs-lisp

; What we write:
(def-class person name age)


;;; What is generated: Ctor
(defun make-person (&key name age)
  ;; Object generated by make-person. It must know how to answer if it is an
  ;; instance of some class and must be able to retrieve the values of the slots.
  (lambda (class-name slot-name)
    (let ((superclass 'nil)             ; Object instance of its superclass (in this case,
                                        ; there's no superclass)
          (slots (...))                 ; Map with slots as keys and they're values as... well,
                                        ; values. ;)
      (cond
        ;; Test if it is the name of the class.
        ((eql class-name 'CLASS-PERSON) 't)
        ;; Search map for the value of the atribute called "name".
        ((eql slot-name 'SLOT-NAME) (...))
        ;; Search map for the value of the atribute called "age".
        ((eql slot-name 'SLOT-AGE) (...))
        ;; Defer the call to the superclass. If there's no superclass, return nil
        ;; (returning nil might be a bad ideia, don't know yet, but I think that's
        ;; how "lispers" do.)
        ('t (...)))))

;;; What is generated: Getters
(defun person-name (p) (p 'nil 'slot-name))
(defun person-age (p) (p 'nil 'slot-age))

;;; What is generated: Recognizer
(defun person? (p) (p 'class-person))

#+END_SRC

